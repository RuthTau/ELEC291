0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.1 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P4.5 is pressed.
                  7   $LIST
0000              9   
0000             10   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             11   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             12   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             13   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             15   
0000             16   BOOT_BUTTON   equ P4.5
0000             17   SOUND_OUT     equ P1.1
0000             18   UPDOWN        equ P0.0
0000             19   
0000             20   CHANGE_HOUR   equ P0.3
0000             21   CHANGE_MINUTE equ P0.6
0000             22   
0000             23   ;ALARM_HOUR    equ 
0000             24   ;ALARM_MIN     equ 
0000             25   
0000             26   
0000             27   
0000             28   
0000             29   
0000             30   ; Reset vector
0000             31   org 0x0000
0000 020162      32       ljmp main
0003             33   
0003             34   ; External interrupt 0 vector (not used in this code)
0003             35   org 0x0003
0003 32          36            reti
0004             37   
0004             38   ; Timer/Counter 0 overflow interrupt vector
000B             39   org 0x000B
000B 020110      40            ljmp Timer0_ISR
000E             41   
000E             42   ; External interrupt 1 vector (not used in this code)
0013             43   org 0x0013
0013 32          44            reti
0014             45   
0014             46   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             47   org 0x001B
001B 32          48            reti
001C             49   
001C             50   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             51   org 0x0023 
0023 32          52            reti
0024             53            
0024             54   ; Timer/Counter 2 overflow interrupt vector
002B             55   org 0x002B
002B 02012C      56            ljmp Timer2_ISR
002E             57   
002E             58   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             59   dseg at 0x30
0030             60   Count1ms:     ds 2 ; Used to determine when half second has passed
0032             61   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033             62   ;Alarm components
0033             63   set_alarm_hours: ds 1 
0034             64   set_alarm_minutes: ds 1 
0035             65   ;Clock components
0035             66   hours_clock: ds 1 
0036             67   minutes_clock: ds 1 
0037             68   seconds_clock: ds 1 
0038             69   ;am_pm
0038             70   ;AM_PM: ds 1 
0038             71   
0038             72   
0038             73   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0038             74   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             75   bseg
0000             76   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             77   
002E             78   cseg
002E             79   ; These 'equ' must match the hardware wiring
002E             80   LCD_RS equ P3.2
002E             81   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E             82   LCD_E  equ P3.3
002E             83   LCD_D4 equ P3.4
002E             84   LCD_D5 equ P3.5
002E             85   LCD_D6 equ P3.6
002E             86   LCD_D7 equ P3.7
002E             87   
                 89   	$LIST
00DA             91   
00DA             92   ;                     1234567890123456    <- This helps determine the location of the counter
00DA 54696D65    93   Initial_Message:  db 'Time   :  :   ', 0
     2020203A
     20203A20
     202000
00E9 416C6172    94   set_alarm:        db 'Alarm   :    ', 0 
     6D202020
     3A202020
     2000
00F7             95   
00F7             96   ;---------------------------------;
00F7             97   ; Routine to initialize the ISR   ;
00F7             98   ; for timer 0                     ;
00F7             99   ;---------------------------------;
00F7            100   Timer0_Init:
00F7 E589       101            mov a, TMOD
00F9 54F0       102            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
00FB 4401       103            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
00FD F589       104            mov TMOD, a
00FF 758CEA     105            mov TH0, #high(TIMER0_RELOAD)
0102 758AE8     106            mov TL0, #low(TIMER0_RELOAD)
0105            107            ; Set autoreload value
0105 75F4EA     108            mov RH0, #high(TIMER0_RELOAD)
0108 75F2E8     109            mov RL0, #low(TIMER0_RELOAD)
010B            110            ; Enable the timer and interrupts
010B D2A9       111       setb ET0  ; Enable timer 0 interrupt
010D D28C       112       setb TR0  ; Start timer 0
010F 22         113            ret
0110            114   
0110            115   ;---------------------------------;
0110            116   ; ISR for timer 0.  Set to execute;
0110            117   ; every 1/4096Hz to generate a    ;
0110            118   ; 2048 Hz square wave at pin P1.1 ;
0110            119   ;---------------------------------;
0110            120   Timer0_ISR:
0110            121            ;clr TF0  ; According to the data sheet this is done for us already.
0110 B291       122            cpl SOUND_OUT ; Connect speaker to P1.1!
0112 32         123            reti
0113            124   
0113            125   ;---------------------------------;
0113            126   ; Routine to initialize the ISR   ;
0113            127   ; for timer 2                     ;
0113            128   ;---------------------------------;
0113            129   Timer2_Init:
0113 75C800     130            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0116 75CDA9     131            mov TH2, #high(TIMER2_RELOAD)
0119 75CC9A     132            mov TL2, #low(TIMER2_RELOAD)
011C            133            ; Set the reload value
011C 75CBA9     134            mov RCAP2H, #high(TIMER2_RELOAD)
011F 75CA9A     135            mov RCAP2L, #low(TIMER2_RELOAD)
0122            136            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0122 E4         137            clr a
0123 F530       138            mov Count1ms+0, a
0125 F531       139            mov Count1ms+1, a
0127            140            ; Enable the timer and interrupts
0127 D2AD       141       setb ET2  ; Enable timer 2 interrupt
0129 D2CA       142       setb TR2  ; Enable timer 2
012B 22         143            ret
012C            144   
012C            145   ;---------------------------------;
012C            146   ; ISR for timer 2                 ;
012C            147   ;---------------------------------;
012C            148   Timer2_ISR:
012C C2CF       149            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
012E B290       150            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0130            151            
0130            152            ; The two registers used in the ISR must be saved in the stack
0130 C0E0       153            push acc
0132 C0D0       154            push psw
0134            155            
0134            156            ; Increment the 16-bit one mili second counter
0134 0530       157            inc Count1ms+0    ; Increment the low 8-bits first
0136 E530       158            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0138 7002       159            jnz Inc_Done
013A 0531       160            inc Count1ms+1
013C            161   
013C            162   Inc_Done:
013C            163            ; Check if half second has passed
013C E530       164            mov a, Count1ms+0
013E B4E81C     165            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0141 E531       166            mov a, Count1ms+1
0143 B40017     167            cjne a, #high(200), Timer2_ISR_done
0146            168            
0146            169            ; 500 milliseconds have passed.  Set a flag so the main program knows
0146 D200       170            setb half_seconds_flag ; Let the main program know half second had passed
0148 B28C       171            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
014A            172            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
014A E4         173            clr a
014B F530       174            mov Count1ms+0, a
014D F531       175            mov Count1ms+1, a
014F            176            ; Increment the BCD counter
014F E537       177            mov a, seconds_clock
0151 308004     178            jnb UPDOWN, Timer2_ISR_decrement
0154 2401       179            add a, #0x01
0156 8002       180            sjmp Timer2_ISR_da
0158            181   Timer2_ISR_decrement:
0158 2499       182            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
015A            183   Timer2_ISR_da:
015A D4         184            da a ; Decimal adjust instruction.  Check datasheet for more details!
015B            185            ;mov BCD_counter, a
015B F537       186            mov seconds_clock, a 
015D            187            
015D            188   Timer2_ISR_done:
015D D0D0       189            pop psw
015F D0E0       190            pop acc
0161 32         191            reti
0162            192   
0162            193   ;---------------------------------;
0162            194   ; Main program. Includes hardware ;
0162            195   ; initialization and 'forever'    ;
0162            196   ; loop.                           ;
0162            197   ;---------------------------------;
0162            198   main:
0162            199            ; Initialization
0162 75817F     200       mov SP, #0x7F
0165 1200F7     201       lcall Timer0_Init
0168 120113     202       lcall Timer2_Init
016B            203       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
016B 75E600     204       mov P0M0, #0
016E 75E700     205       mov P0M1, #0
0171 D2AF       206       setb EA   ; Enable Global interrupts
0173 120088     207       lcall LCD_4BIT
0176            208       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
0176 C0E0       209            push acc
0178 7401       209            mov a, #1
017A 14         209            dec a
017B 1200BF     209            lcall ?Set_Cursor_1 ; Select column and row
017E D0E0       209            pop acc
0180 C083       210            push dph
0182 C082       210            push dpl
0184 C0E0       210            push acc
0186 9000DA     210            mov dptr, #Initial_Message
0189 1200B2     210            lcall ?Send_Constant_String
018C D0E0       210            pop acc
018E D082       210            pop dpl
0190 D083       210            pop dph
0192 C0E0       211            push acc
0194 7401       211            mov a, #1
0196 14         211            dec a
0197 1200BD     211            lcall ?Set_Cursor_2 ; Select column and row
019A D0E0       211            pop acc
019C C083       212            push dph
019E C082       212            push dpl
01A0 C0E0       212            push acc
01A2 9000E9     212            mov dptr, #set_alarm
01A5 1200B2     212            lcall ?Send_Constant_String
01A8 D0E0       212            pop acc
01AA D082       212            pop dpl
01AC D083       212            pop dph
01AE D200       213       setb half_seconds_flag
01B0            214            ;mov BCD_counter, #0x00
01B0 753512     215            mov hours_clock, #0x12 
01B3 753658     216            mov minutes_clock, #0x58 
01B6 753700     217            mov seconds_clock, #0x00 
01B9 753312     218            mov set_alarm_hours, #0x12
01BC 753402     219            mov set_alarm_minutes, #0x02
01BF            220            ; After initialization the program stays in this 'forever' loop
01BF            221   loop:
01BF 20C51C     222            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
01C2 C002       223            push AR2
01C4 7A32       223            mov R2, #50
01C6 120039     223            lcall ?Wait_Milli_Seconds
01C9 D002       223            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
01CB 20C510     224            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
01CE 30C5FD     225            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
01D1            226            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
01D1            227            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
01D1 C2CA       228            clr TR2                 ; Stop timer 2
01D3 E4         229            clr a
01D4 F530       230            mov Count1ms+0, a
01D6 F531       231            mov Count1ms+1, a
01D8            232            ; Now clear the BCD counter
01D8            233            ;mov BCD_counter, a
01D8            234            ;mov hours_clock, a 
01D8            235            ;mov minutes_clock, a 
01D8 F537       236            mov seconds_clock, a 
01DA            237   
01DA D2CA       238            setb TR2                ; Start timer 2
01DC 8003       239            sjmp loop_b             ; Display the new value
01DE            240   loop_a:
01DE 3000DE     241            jnb half_seconds_flag, loop
01E1            242   loop_b:
01E1 C200       243       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
01E3            244       ;display alarm
01E3 C0E0       245            push acc
01E5 7401       245            mov a, #1
01E7 14         245            dec a
01E8 1200BD     245            lcall ?Set_Cursor_2 ; Select column and row
01EB D0E0       245            pop acc     ; the place in the LCD where we want the BCD counter value
01ED C083       246            push dph
01EF C082       246            push dpl
01F1 C0E0       246            push acc
01F3 9000E9     246            mov dptr, #set_alarm
01F6 1200B2     246            lcall ?Send_Constant_String
01F9 D0E0       246            pop acc
01FB D082       246            pop dpl
01FD D083       246            pop dph
01FF            247            ;Display_BCD(set_alarm_hours) ; This macro is also in 'LCD_4bit.inc'
01FF C0E0       248            push acc
0201 7407       248            mov a, #7
0203 14         248            dec a
0204 1200BD     248            lcall ?Set_Cursor_2 ; Select column and row
0207 D0E0       248            pop acc     ; the place in the LCD where we want the BCD counter value
0209 C000       249            push ar0
020B A833       249            mov r0, set_alarm_hours
020D 1200C4     249            lcall ?Display_BCD
0210 D000       249            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0212 C0E0       250            push acc
0214 740A       250            mov a, #10
0216 14         250            dec a
0217 1200BD     250            lcall ?Set_Cursor_2 ; Select column and row
021A D0E0       250            pop acc     ; the place in the LCD where we want the BCD counter value
021C C000       251            push ar0
021E A834       251            mov r0, set_alarm_minutes
0220 1200C4     251            lcall ?Display_BCD
0223 D000       251            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0225            252            
0225            253            ;display clock
0225 C0E0       254            push acc
0227 7401       254            mov a, #1
0229 14         254            dec a
022A 1200BF     254            lcall ?Set_Cursor_1 ; Select column and row
022D D0E0       254            pop acc     ; the place in the LCD where we want the BCD counter value
022F C083       255            push dph
0231 C082       255            push dpl
0233 C0E0       255            push acc
0235 9000DA     255            mov dptr, #Initial_Message
0238 1200B2     255            lcall ?Send_Constant_String
023B D0E0       255            pop acc
023D D082       255            pop dpl
023F D083       255            pop dph
0241            256            ;Display_BCD(hours_clock) ; This macro is also in 'LCD_4bit.inc'
0241 C0E0       257            push acc
0243 7406       257            mov a, #6
0245 14         257            dec a
0246 1200BF     257            lcall ?Set_Cursor_1 ; Select column and row
0249 D0E0       257            pop acc     ; the place in the LCD where we want the BCD counter value
024B C000       258            push ar0
024D A835       258            mov r0, hours_clock
024F 1200C4     258            lcall ?Display_BCD
0252 D000       258            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0254            259            ;Display_BCD(minutes_clock) ; This macro is also in 'LCD_4bit.inc'
0254 C0E0       260            push acc
0256 7409       260            mov a, #9
0258 14         260            dec a
0259 1200BF     260            lcall ?Set_Cursor_1 ; Select column and row
025C D0E0       260            pop acc     ; the place in the LCD where we want the BCD counter value
025E C000       261            push ar0
0260 A836       261            mov r0, minutes_clock
0262 1200C4     261            lcall ?Display_BCD
0265 D000       261            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0267 C0E0       262            push acc
0269 740C       262            mov a, #12
026B 14         262            dec a
026C 1200BF     262            lcall ?Set_Cursor_1 ; Select column and row
026F D0E0       262            pop acc     ; the place in the LCD where we want the BCD counter value
0271 C000       263            push ar0
0273 A837       263            mov r0, seconds_clock
0275 1200C4     263            lcall ?Display_BCD
0278 D000       263            pop ar0 ; This macro is also in 'LCD_4bit.inc'
027A            264            
027A            265            
027A E537       266            mov a , seconds_clock 
027C B45922     267       cjne a, #0x59,button
027F 8000       268       sjmp compare_time
0281            269      
0281            270   compare_time:
0281            271   
0281 753700     272            mov seconds_clock, #0x00
0284 E536       273            mov a, minutes_clock
0286 2401       274            add a, #0x01
0288 D4         275            da a
0289 F536       276            mov minutes_clock, a
028B            277            
028B B46013     278            cjne a, #0x60, button
028E 753600     279            mov minutes_clock, #0x00
0291 E535       280            mov a, hours_clock
0293 2401       281            add a, #0x01
0295 D4         282            da a
0296 F535       283            mov hours_clock, a
0298            284            
0298 B41306     285            cjne a, #0x13, button
029B 753501     286            mov hours_clock, #0x01
029E 0202E9     287            ljmp loop_go
02A1            288   
02A1            289       
02A1            290       
02A1            291      
02A1            292   button:
02A1 8000       293            sjmp hr_btn_clk 
02A3            294   
02A3            295   hr_btn_clk:
02A3 D283       296            setb CHANGE_HOUR 
02A5 308302     297            jnb CHANGE_HOUR, hr_inc_button 
02A8 800F       298            sjmp min_btn_clk 
02AA            299   
02AA            300   hr_inc_button:
02AA E535       301            mov a, hours_clock 
02AC 2401       302            add a, #0x01 
02AE D4         303            da a 
02AF F535       304            mov hours_clock, a 
02B1 B41305     305            cjne a, #0x13, min_btn_clk
02B4 753501     306            mov hours_clock, #0x01 
02B7 8000       307            sjmp min_btn_clk 
02B9            308   
02B9            309   min_btn_clk:
02B9 D286       310            setb CHANGE_MINUTE 
02BB 30860E     311            jnb CHANGE_MINUTE, min_inc_button 
02BE C002       312            push AR2
02C0 7A32       312            mov R2, #50
02C2 120039     312            lcall ?Wait_Milli_Seconds
02C5 D002       312            pop AR2
02C7 308602     313            jnb CHANGE_MINUTE, min_inc_button
02CA 801D       314            sjmp loop_go 
02CC            315   
02CC            316   min_inc_button:
02CC E536       317            mov a, minutes_clock 
02CE 2401       318       add a, #0x01 
02D0 D4         319       da a 
02D1 F536       320       mov minutes_clock, a 
02D3 B46013     321       cjne a, #0x60, loop_go 
02D6 753600     322       mov minutes_clock, #0x00
02D9 E535       323       mov a, hours_clock
02DB 2401       324       add a, #0x01 
02DD D4         325       da a 
02DE F535       326       mov hours_clock, a 
02E0 B41306     327       cjne a, #0x13, loop_go 
02E3 753501     328       mov hours_clock, #0x01 
02E6 0202E9     329       ljmp loop_go
02E9            330   
02E9            331   
02E9            332   
02E9            333   
02E9            334   
02E9            335            
02E9            336   loop_go:
02E9 0201BF     337    ljmp loop
02EC            338   
02EC            339   
02EC            340   
02EC            341   EN
